package com.simomics.leishsim.test;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Rule;
import org.junit.contrib.java.lang.system.SystemErrRule;
import org.junit.contrib.java.lang.system.SystemOutRule;

import com.simomics.leishsim.Logging;
import com.simomics.leishsim.Logging.LogType;
import com.simomics.leishsim.TextFileLogger;

/**
 * Abstract base class for creating high-level system tests 
 *   on the output (printed to stdout) of the whole simulator.
 * Captures stdout and stderr to member variables.
 */
public class OutputTest {
	
	/** Captured contents of stdout */
	@Rule
    public final SystemOutRule systemOutRule = new SystemOutRule().enableLog();
	
	/** Captured contents of stderr */
	@Rule
    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog();
	
	/**
	 * @param fileName
	 * @return The given file name within the test model files directory 
	 */
	protected static String getModelFilePath(String fileName) {
		return getResourcePath("/model_files/" + fileName);
	}
	
	/**
	 * @param fileName
	 * @return The given file name within the test resources directory
	 */
	protected static String getResourcePath(String fileName) {
		try {
			// Class.getResource allows the file to be located on a local machine and on Jenkins
			// URLDecoder handles spaces in file paths
			// new File fixes URLs of absolute paths on Windows, for giving to external tools like Python
			return new File(URLDecoder.decode(OutputTest.class.getResource(fileName).getFile(), "UTF-8")).getAbsolutePath();
		} catch (UnsupportedEncodingException e) {
			return null;
		}
	}
	
	/**
	 * Reads a results file, named: "results_{prefix}_{numHours}_{randomSeed}.txt"
	 * @param numHours The number of hours to run the simulation.
	 * @param randomSeed The seed used for the simulation.
	 * @return The contents of the file
	 * @throws IOException | URISyntaxException If the file could not be read.
	 */
	protected static String readResultsFile(String prefix, int numHours, long randomSeed) throws IOException, URISyntaxException {
		return readFilefromName(String.format("/results_%s_%d_%d.txt", prefix, numHours, randomSeed), "\r\n", true);
	}
	
	/**
	 * Reads a results file named: "results_{prefix}.txt"
	 * @return The contents of the file
	 * @throws IOException | URISyntaxException If the file could not be read.
	 */
	protected static String readResultsFile(String prefix) throws IOException, URISyntaxException {
		return readFilefromName(String.format("/results_%s.txt", prefix), "\r\n", true);
	}
	
	/**
	 * Reads a file of initial conditions.
	 * @return A string that can be compared with systemErrRule.getLog()
	 */
	protected static String readInitialConditionsFile(String fileName) throws IOException, URISyntaxException {
		return readFilefromName(fileName, "\n", false);
	}
	
	/**
	 * Reads the log file generated by one of the built-in loggers
	 * @param logType
	 * @return The contents of the log file
	 */
	protected static String readLogFile(LogType logType) throws IOException, URISyntaxException {
		Path logFilePath = Paths.get(((TextFileLogger) Logging.getLogger(logType.name())).getLogFile().getAbsolutePath());
		return readFileFromPath(logFilePath, "\n", false);
	}
	
	/**
	 * Read a results file into a String
	 * @param fileName The name of the file, relative to the class that is calling this method.
	 * @param newline The newline character sequence to use to separate lines in the file. 
	 *                So that we can compare to system output.
	 * @param finalNewline Whether to add a final newline after the last line.
	 * @return The contents of the file.
	 * @throws IOException | URISyntaxException If the file could not be read.
	 */
	protected static String readFilefromName(String fileName, String newline, boolean finalNewline) throws IOException, URISyntaxException {
		return readFileFromPath(Paths.get(OutputTest.class.getResource(fileName).toURI()), newline, finalNewline);
	}
	
	protected static String readFileFromPath(Path filePath, String newline, boolean finalNewline) throws IOException, URISyntaxException {
		List<String> lines = Files.readAllLines(filePath);
		StringBuilder fileContents = new StringBuilder();
		for (String line : lines) {
			fileContents.append(line);
			fileContents.append(newline);
		}
		if (!lines.isEmpty() && !finalNewline) {
			fileContents.setLength(fileContents.length() - newline.length());
		}
		return fileContents.toString();
	}
	
	/**
	 * Parses the printed species file into numbers.
	 * @param lineNumber The line of the species file to return. Use negative numbers to index backwards. The last line is index -1.
	 * @return A map of species name to concentration for the given line in the file.
	 * @throws IOException | URISyntaxException
	 */
	protected static Map<String, Integer> getLineOfSpeciesFile(int lineNumber) throws IOException, URISyntaxException {
		String[] lines = readLogFile(LogType.PRINTED_SPECIES).split("\n");
		if (lineNumber < 0) {
			lineNumber = lines.length + lineNumber; 
		}
		String[] headings = lines[0].split(",");
		String[] concentrations = lines[lineNumber].split(",");
		Map<String, Integer> results = new HashMap<>();
		for (int i=1; i<headings.length; i++) {
			results.put(headings[i].trim(), new Integer(concentrations[i].trim()));
		}
		return results;
	}
	
	/**
	 * Parses the printed species file into numbers.
	 * @return A map of species name to concentration, for every line in the file.
	 */
	protected static List<Map<String, Integer>> readPrintedSpeciesFile() throws IOException, URISyntaxException {
		String[] lines = readLogFile(LogType.PRINTED_SPECIES).split("\n");
		String[] headings = lines[0].split(",");
		List<Map<String, Integer>> results = new ArrayList<>();
		for (int lineNumber = 1; lineNumber < lines.length; lineNumber++) {
			String[] concentrations = lines[lineNumber].split(",");
			Map<String, Integer> resultsThisLine = new HashMap<>();
			for (int speciesIndex = 1; speciesIndex < headings.length; speciesIndex++) {
				resultsThisLine.put(headings[speciesIndex].trim(), new Integer(concentrations[speciesIndex].trim()));
			}
			results.add(resultsThisLine);
		}
		return results;
	}
	
	/**
	 * Reads the PRINTED_SPECIES log file and measures the half life of the given species.
	 * ASSUMES: that this species is only involved in a single decay reaction. 
	 * This function measures the time that the species takes to reach half of its initial concentration. 
	 * @return The half life in hours or seconds (whichever is printed in the log file), or null if we don't see the concentration halve during this run. 
	 */
	public static Integer measureHalfLife(String speciesName) throws IOException, URISyntaxException {
		List<Map<String, Integer>> speciesNumbers = readPrintedSpeciesFile();
		Map<String, Integer> initialConcentrations = speciesNumbers.get(0);
		Integer initialConcentration = initialConcentrations.get(speciesName);
		Integer initialTime = null;
		if (initialConcentrations.containsKey("Hours")) {
			initialTime = initialConcentrations.get("Hours");
		}
		else {
			initialTime = initialConcentrations.get("Seconds");
		}
		// Go through each line in the species file until we reduce to less than half of the initial concentration
		for (Map<String, Integer> concentrations: speciesNumbers) {
			if (concentrations.get(speciesName) < initialConcentration / 2) {
				Integer currentTime = null;
				if (concentrations.containsKey("Hours")) {
					currentTime = concentrations.get("Hours");
				}
				else {
					currentTime = concentrations.get("Seconds");
				}
				return currentTime - initialTime;
			}
		}
		return null;
	}
}
